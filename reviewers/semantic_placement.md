---
title: 実装箇所
---

## 責務

このレビュワーの責務は **実装箇所が意味的に適切かどうかの検証** です。

### 対象とする問題

1. **基底クラスのオーバーライド漏れ**
   - 基底クラスの virtual/abstract メソッドを override すべきところ、別メソッドで実装している
   - 例: `OnDestroy()` を override せず、独自の `Cleanup()` メソッドを作成
   - リスク: 将来的に処理の呼び出し漏れが発生する

2. **クラス間の責務違反**
   - Model に実装すべき処理が View にある
   - Controller の処理が View に漏れている
   - ビジネスロジックがプレゼンテーション層にある
   - 例: データの計算処理が View クラスに実装されている

3. **より適切な実装場所の存在**
   - 同じ責務を持つ既存クラスがあるのに、新しいクラスに実装している
   - 既存のユーティリティクラスに追加すべき処理が別の場所にある
   - 実装者がそのクラスやメソッドの存在に気づいていない可能性が高い

## 分析手順

1. **変更内容の理解**: 新規追加・変更されたメソッドや処理の内容を把握
2. **継承関係の調査**:
   - 変更クラスの基底クラスを確認
   - virtual/abstract メソッドの一覧を取得
   - override すべきメソッドがないか確認
3. **クラス責務の分析**:
   - 変更クラスの責務（View/Model/Controller等）を特定
   - 追加された処理がその責務に合致しているか確認
4. **関連クラスの調査**:
   - 同じ名前空間・ディレクトリ内の関連クラスを確認
   - より適切な実装場所がないか検討

## 報告しないケース

- 意図的な設計判断による配置（パフォーマンス最適化など）
- テストコード内での実装
- 一時的な実装であることが明記されている場合
- 単純な private ヘルパーメソッドの追加

## reasonテンプレート

### 基底クラスのオーバーライド漏れの場合

【実装されたメソッド】
```csharp
// 新しく追加されたメソッド
```

【override すべき基底メソッド】
- クラス: [基底クラス名]
- メソッド: [virtual/abstract メソッド名]
- 理由: [なぜこのメソッドを override すべきか]

【推奨対応】
- [基底メソッド名] を override し、そこで処理を実行することで、呼び出し漏れを防止できます

### クラス間の責務違反の場合

【現在の実装場所】
- ファイル: [パス]
- クラス: [クラス名]
- 責務: [View/Model/Controller等]

【より適切な実装場所】
- ファイル: [パス]
- クラス: [クラス名]
- 理由: [なぜそちらが適切か]

### より適切な実装場所が存在する場合

【現在の実装】
```csharp
// 追加されたコード
```

【推奨する実装場所】
- ファイル: [パス]
- クラス/メソッド: [名前]
- 理由: [なぜそちらが適切か、実装者が気づいていない可能性がある理由]
